{"ast":null,"code":"import{Plugins}from'@capacitor/core';const{Storage}=Plugins;const dataUrl='/assets/data/data.json';const locationsUrl='/assets/data/locations.json';const HAS_LOGGED_IN='hasLoggedIn';const HAS_SEEN_TUTORIAL='hasSeenTutorial';const USERNAME='username';export const getConfData=async()=>{const response=await Promise.all([fetch(dataUrl),fetch(locationsUrl)]);const responseData=await response[0].json();const schedule=responseData.schedule[0];const sessions=parseSessions(schedule);const speakers=responseData.speakers;const locations=await response[1].json();const allTracks=sessions.reduce((all,session)=>all.concat(session.tracks),[]).filter((trackName,index,array)=>array.indexOf(trackName)===index).sort();const data={schedule,sessions,locations,speakers,allTracks,filteredTracks:[...allTracks]};return data;};export const getUserData=async()=>{const response=await Promise.all([Storage.get({key:HAS_LOGGED_IN}),Storage.get({key:HAS_SEEN_TUTORIAL}),Storage.get({key:USERNAME})]);const isLoggedin=(await response[0].value)==='true';const hasSeenTutorial=(await response[1].value)==='true';const username=(await response[2].value)||undefined;const data={isLoggedin,hasSeenTutorial,username};return data;};export const setIsLoggedInData=async isLoggedIn=>{await Storage.set({key:HAS_LOGGED_IN,value:JSON.stringify(isLoggedIn)});};export const setHasSeenTutorialData=async hasSeenTutorial=>{await Storage.set({key:HAS_SEEN_TUTORIAL,value:JSON.stringify(hasSeenTutorial)});};export const setUsernameData=async username=>{if(!username){await Storage.remove({key:USERNAME});}else{await Storage.set({key:USERNAME,value:username});}};function parseSessions(schedule){const sessions=[];schedule.groups.forEach(g=>{g.sessions.forEach(s=>sessions.push(s));});return sessions;}","map":{"version":3,"sources":["D:/DT/ptmsCheckOutNew/New-MobileApp/src/data/dataApi.ts"],"names":["Plugins","Storage","dataUrl","locationsUrl","HAS_LOGGED_IN","HAS_SEEN_TUTORIAL","USERNAME","getConfData","response","Promise","all","fetch","responseData","json","schedule","sessions","parseSessions","speakers","locations","allTracks","reduce","session","concat","tracks","filter","trackName","index","array","indexOf","sort","data","filteredTracks","getUserData","get","key","isLoggedin","value","hasSeenTutorial","username","undefined","setIsLoggedInData","isLoggedIn","set","JSON","stringify","setHasSeenTutorialData","setUsernameData","remove","groups","forEach","g","s","push"],"mappings":"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","sourcesContent":["import { Plugins } from '@capacitor/core';\r\nimport { Schedule, Session } from '../models/Schedule';\r\nimport { Speaker } from '../models/Speaker';\r\nimport { Location } from '../models/Location';\r\n\r\nconst { Storage } = Plugins;\r\n\r\nconst dataUrl = '/assets/data/data.json';\r\nconst locationsUrl = '/assets/data/locations.json';\r\n\r\nconst HAS_LOGGED_IN = 'hasLoggedIn';\r\nconst HAS_SEEN_TUTORIAL = 'hasSeenTutorial';\r\nconst USERNAME = 'username';\r\n\r\nexport const getConfData = async () => {\r\n  const response = await Promise.all([\r\n    fetch(dataUrl),\r\n    fetch(locationsUrl)]);\r\n  const responseData = await response[0].json();\r\n  const schedule = responseData.schedule[0] as Schedule;\r\n  const sessions = parseSessions(schedule);\r\n  const speakers = responseData.speakers as Speaker[];\r\n  const locations = await response[1].json() as Location[];\r\n  const allTracks = sessions\r\n    .reduce((all, session) => all.concat(session.tracks), [] as string[])\r\n    .filter((trackName, index, array) => array.indexOf(trackName) === index)\r\n    .sort();\r\n\r\n  const data = {\r\n    schedule,\r\n    sessions,\r\n    locations,\r\n    speakers,\r\n    allTracks,\r\n    filteredTracks: [...allTracks]\r\n  }\r\n  return data;\r\n}\r\n\r\nexport const getUserData = async () => {\r\n  const response = await Promise.all([\r\n    Storage.get({ key: HAS_LOGGED_IN }),\r\n    Storage.get({ key: HAS_SEEN_TUTORIAL }),\r\n    Storage.get({ key: USERNAME })]);\r\n  const isLoggedin = await response[0].value === 'true';\r\n  const hasSeenTutorial = await response[1].value === 'true';\r\n  const username = await response[2].value || undefined;\r\n  const data = {\r\n    isLoggedin,\r\n    hasSeenTutorial,\r\n    username\r\n  }\r\n  return data;\r\n}\r\n\r\nexport const setIsLoggedInData = async (isLoggedIn: boolean) => {\r\n  await Storage.set({ key: HAS_LOGGED_IN, value: JSON.stringify(isLoggedIn) });\r\n}\r\n\r\nexport const setHasSeenTutorialData = async (hasSeenTutorial: boolean) => {\r\n  await Storage.set({ key: HAS_SEEN_TUTORIAL, value: JSON.stringify(hasSeenTutorial) });\r\n}\r\n\r\nexport const setUsernameData = async (username?: string) => {\r\n  if (!username) {\r\n    await Storage.remove({ key: USERNAME });\r\n  } else {\r\n    await Storage.set({ key: USERNAME, value: username });\r\n  }\r\n}\r\n\r\nfunction parseSessions(schedule: Schedule) {\r\n  const sessions: Session[] = [];\r\n  schedule.groups.forEach(g => {\r\n    g.sessions.forEach(s => sessions.push(s))\r\n  });\r\n  return sessions;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}